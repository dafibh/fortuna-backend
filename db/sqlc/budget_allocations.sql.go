// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: budget_allocations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteBudgetAllocation = `-- name: DeleteBudgetAllocation :exec
DELETE FROM budget_allocations
WHERE workspace_id = $1 AND category_id = $2 AND year = $3 AND month = $4
`

type DeleteBudgetAllocationParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	CategoryID  int32 `json:"category_id"`
	Year        int32 `json:"year"`
	Month       int32 `json:"month"`
}

func (q *Queries) DeleteBudgetAllocation(ctx context.Context, arg DeleteBudgetAllocationParams) error {
	_, err := q.db.Exec(ctx, deleteBudgetAllocation,
		arg.WorkspaceID,
		arg.CategoryID,
		arg.Year,
		arg.Month,
	)
	return err
}

const getBudgetAllocationByCategory = `-- name: GetBudgetAllocationByCategory :one
SELECT id, workspace_id, category_id, year, month, amount, created_at, updated_at FROM budget_allocations
WHERE workspace_id = $1 AND category_id = $2 AND year = $3 AND month = $4
`

type GetBudgetAllocationByCategoryParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	CategoryID  int32 `json:"category_id"`
	Year        int32 `json:"year"`
	Month       int32 `json:"month"`
}

func (q *Queries) GetBudgetAllocationByCategory(ctx context.Context, arg GetBudgetAllocationByCategoryParams) (BudgetAllocation, error) {
	row := q.db.QueryRow(ctx, getBudgetAllocationByCategory,
		arg.WorkspaceID,
		arg.CategoryID,
		arg.Year,
		arg.Month,
	)
	var i BudgetAllocation
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CategoryID,
		&i.Year,
		&i.Month,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBudgetAllocationsByMonth = `-- name: GetBudgetAllocationsByMonth :many
SELECT ba.id, ba.workspace_id, ba.category_id, ba.year, ba.month, ba.amount, ba.created_at, ba.updated_at, bc.name AS category_name
FROM budget_allocations ba
JOIN budget_categories bc ON ba.category_id = bc.id
WHERE ba.workspace_id = $1 AND ba.year = $2 AND ba.month = $3
ORDER BY bc.name ASC
`

type GetBudgetAllocationsByMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	Year        int32 `json:"year"`
	Month       int32 `json:"month"`
}

type GetBudgetAllocationsByMonthRow struct {
	ID           int32              `json:"id"`
	WorkspaceID  int32              `json:"workspace_id"`
	CategoryID   int32              `json:"category_id"`
	Year         int32              `json:"year"`
	Month        int32              `json:"month"`
	Amount       pgtype.Numeric     `json:"amount"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	CategoryName string             `json:"category_name"`
}

func (q *Queries) GetBudgetAllocationsByMonth(ctx context.Context, arg GetBudgetAllocationsByMonthParams) ([]GetBudgetAllocationsByMonthRow, error) {
	rows, err := q.db.Query(ctx, getBudgetAllocationsByMonth, arg.WorkspaceID, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBudgetAllocationsByMonthRow{}
	for rows.Next() {
		var i GetBudgetAllocationsByMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CategoryID,
			&i.Year,
			&i.Month,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesWithAllocations = `-- name: GetCategoriesWithAllocations :many
SELECT
    bc.id AS category_id,
    bc.name AS category_name,
    COALESCE(ba.amount, 0) AS allocated
FROM budget_categories bc
LEFT JOIN budget_allocations ba ON bc.id = ba.category_id
    AND ba.year = $2 AND ba.month = $3 AND ba.workspace_id = $1
WHERE bc.workspace_id = $1 AND bc.deleted_at IS NULL
ORDER BY bc.name ASC
`

type GetCategoriesWithAllocationsParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	Year        int32 `json:"year"`
	Month       int32 `json:"month"`
}

type GetCategoriesWithAllocationsRow struct {
	CategoryID   int32          `json:"category_id"`
	CategoryName string         `json:"category_name"`
	Allocated    pgtype.Numeric `json:"allocated"`
}

// Returns all categories with their allocation for a specific month (0 if not set)
func (q *Queries) GetCategoriesWithAllocations(ctx context.Context, arg GetCategoriesWithAllocationsParams) ([]GetCategoriesWithAllocationsRow, error) {
	rows, err := q.db.Query(ctx, getCategoriesWithAllocations, arg.WorkspaceID, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoriesWithAllocationsRow{}
	for rows.Next() {
		var i GetCategoriesWithAllocationsRow
		if err := rows.Scan(&i.CategoryID, &i.CategoryName, &i.Allocated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertBudgetAllocation = `-- name: UpsertBudgetAllocation :one
INSERT INTO budget_allocations (workspace_id, category_id, year, month, amount)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (workspace_id, category_id, year, month)
DO UPDATE SET amount = EXCLUDED.amount, updated_at = NOW()
RETURNING id, workspace_id, category_id, year, month, amount, created_at, updated_at
`

type UpsertBudgetAllocationParams struct {
	WorkspaceID int32          `json:"workspace_id"`
	CategoryID  int32          `json:"category_id"`
	Year        int32          `json:"year"`
	Month       int32          `json:"month"`
	Amount      pgtype.Numeric `json:"amount"`
}

func (q *Queries) UpsertBudgetAllocation(ctx context.Context, arg UpsertBudgetAllocationParams) (BudgetAllocation, error) {
	row := q.db.QueryRow(ctx, upsertBudgetAllocation,
		arg.WorkspaceID,
		arg.CategoryID,
		arg.Year,
		arg.Month,
		arg.Amount,
	)
	var i BudgetAllocation
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CategoryID,
		&i.Year,
		&i.Month,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
