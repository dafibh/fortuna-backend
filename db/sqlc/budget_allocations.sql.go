// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: budget_allocations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const copyAllocationsToMonth = `-- name: CopyAllocationsToMonth :exec
INSERT INTO budget_allocations (workspace_id, category_id, year, month, amount)
SELECT ba.workspace_id, ba.category_id, $1::int, $2::int, ba.amount
FROM budget_allocations ba
JOIN budget_categories bc ON ba.category_id = bc.id
WHERE ba.workspace_id = $3
    AND ba.year = $4::int
    AND ba.month = $5::int
    AND bc.deleted_at IS NULL
ON CONFLICT (workspace_id, category_id, year, month) DO NOTHING
`

type CopyAllocationsToMonthParams struct {
	ToYear      int32 `json:"to_year"`
	ToMonth     int32 `json:"to_month"`
	WorkspaceID int32 `json:"workspace_id"`
	FromYear    int32 `json:"from_year"`
	FromMonth   int32 `json:"from_month"`
}

// Copies all allocations from one month to another (atomic, skips deleted categories)
func (q *Queries) CopyAllocationsToMonth(ctx context.Context, arg CopyAllocationsToMonthParams) error {
	_, err := q.db.Exec(ctx, copyAllocationsToMonth,
		arg.ToYear,
		arg.ToMonth,
		arg.WorkspaceID,
		arg.FromYear,
		arg.FromMonth,
	)
	return err
}

const countAllocationsForMonth = `-- name: CountAllocationsForMonth :one
SELECT COUNT(*) FROM budget_allocations
WHERE workspace_id = $1 AND year = $2 AND month = $3
`

type CountAllocationsForMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	Year        int32 `json:"year"`
	Month       int32 `json:"month"`
}

// Returns the count of allocations for a specific month (for lazy initialization check)
func (q *Queries) CountAllocationsForMonth(ctx context.Context, arg CountAllocationsForMonthParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllocationsForMonth, arg.WorkspaceID, arg.Year, arg.Month)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteBudgetAllocation = `-- name: DeleteBudgetAllocation :exec
DELETE FROM budget_allocations
WHERE workspace_id = $1 AND category_id = $2 AND year = $3 AND month = $4
`

type DeleteBudgetAllocationParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	CategoryID  int32 `json:"category_id"`
	Year        int32 `json:"year"`
	Month       int32 `json:"month"`
}

func (q *Queries) DeleteBudgetAllocation(ctx context.Context, arg DeleteBudgetAllocationParams) error {
	_, err := q.db.Exec(ctx, deleteBudgetAllocation,
		arg.WorkspaceID,
		arg.CategoryID,
		arg.Year,
		arg.Month,
	)
	return err
}

const getBudgetAllocationByCategory = `-- name: GetBudgetAllocationByCategory :one
SELECT id, workspace_id, category_id, year, month, amount, created_at, updated_at FROM budget_allocations
WHERE workspace_id = $1 AND category_id = $2 AND year = $3 AND month = $4
`

type GetBudgetAllocationByCategoryParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	CategoryID  int32 `json:"category_id"`
	Year        int32 `json:"year"`
	Month       int32 `json:"month"`
}

func (q *Queries) GetBudgetAllocationByCategory(ctx context.Context, arg GetBudgetAllocationByCategoryParams) (BudgetAllocation, error) {
	row := q.db.QueryRow(ctx, getBudgetAllocationByCategory,
		arg.WorkspaceID,
		arg.CategoryID,
		arg.Year,
		arg.Month,
	)
	var i BudgetAllocation
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CategoryID,
		&i.Year,
		&i.Month,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBudgetAllocationsByMonth = `-- name: GetBudgetAllocationsByMonth :many
SELECT ba.id, ba.workspace_id, ba.category_id, ba.year, ba.month, ba.amount, ba.created_at, ba.updated_at, bc.name AS category_name
FROM budget_allocations ba
JOIN budget_categories bc ON ba.category_id = bc.id
WHERE ba.workspace_id = $1 AND ba.year = $2 AND ba.month = $3
ORDER BY bc.name ASC
`

type GetBudgetAllocationsByMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	Year        int32 `json:"year"`
	Month       int32 `json:"month"`
}

type GetBudgetAllocationsByMonthRow struct {
	ID           int32              `json:"id"`
	WorkspaceID  int32              `json:"workspace_id"`
	CategoryID   int32              `json:"category_id"`
	Year         int32              `json:"year"`
	Month        int32              `json:"month"`
	Amount       pgtype.Numeric     `json:"amount"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	CategoryName string             `json:"category_name"`
}

func (q *Queries) GetBudgetAllocationsByMonth(ctx context.Context, arg GetBudgetAllocationsByMonthParams) ([]GetBudgetAllocationsByMonthRow, error) {
	rows, err := q.db.Query(ctx, getBudgetAllocationsByMonth, arg.WorkspaceID, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBudgetAllocationsByMonthRow{}
	for rows.Next() {
		var i GetBudgetAllocationsByMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.CategoryID,
			&i.Year,
			&i.Month,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesWithAllocations = `-- name: GetCategoriesWithAllocations :many
SELECT
    bc.id AS category_id,
    bc.name AS category_name,
    COALESCE(ba.amount, 0) AS allocated
FROM budget_categories bc
LEFT JOIN budget_allocations ba ON bc.id = ba.category_id
    AND ba.year = $2 AND ba.month = $3 AND ba.workspace_id = $1
WHERE bc.workspace_id = $1 AND bc.deleted_at IS NULL
ORDER BY bc.name ASC
`

type GetCategoriesWithAllocationsParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	Year        int32 `json:"year"`
	Month       int32 `json:"month"`
}

type GetCategoriesWithAllocationsRow struct {
	CategoryID   int32          `json:"category_id"`
	CategoryName string         `json:"category_name"`
	Allocated    pgtype.Numeric `json:"allocated"`
}

// Returns all categories with their allocation for a specific month (0 if not set)
func (q *Queries) GetCategoriesWithAllocations(ctx context.Context, arg GetCategoriesWithAllocationsParams) ([]GetCategoriesWithAllocationsRow, error) {
	rows, err := q.db.Query(ctx, getCategoriesWithAllocations, arg.WorkspaceID, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoriesWithAllocationsRow{}
	for rows.Next() {
		var i GetCategoriesWithAllocationsRow
		if err := rows.Scan(&i.CategoryID, &i.CategoryName, &i.Allocated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryTransactions = `-- name: GetCategoryTransactions :many
SELECT t.id, t.workspace_id, t.account_id, t.name, t.amount, t.type, t.transaction_date, t.is_paid, t.notes, t.created_at, t.updated_at, t.deleted_at, t.transfer_pair_id, t.category_id, t.is_cc_payment, t.billed_at, t.settlement_intent, t.source, t.template_id, t.is_projected, t.loan_id, t.group_id, a.name AS account_name
FROM transactions t
JOIN accounts a ON t.account_id = a.id
WHERE t.workspace_id = $1
    AND t.category_id = $2
    AND t.type = 'expense'
    AND t.deleted_at IS NULL
    AND EXTRACT(YEAR FROM t.transaction_date) = $3::int
    AND EXTRACT(MONTH FROM t.transaction_date) = $4::int
ORDER BY t.transaction_date DESC
`

type GetCategoryTransactionsParams struct {
	WorkspaceID int32       `json:"workspace_id"`
	CategoryID  pgtype.Int4 `json:"category_id"`
	Year        int32       `json:"year"`
	Month       int32       `json:"month"`
}

type GetCategoryTransactionsRow struct {
	ID               int32              `json:"id"`
	WorkspaceID      int32              `json:"workspace_id"`
	AccountID        int32              `json:"account_id"`
	Name             string             `json:"name"`
	Amount           pgtype.Numeric     `json:"amount"`
	Type             string             `json:"type"`
	TransactionDate  pgtype.Date        `json:"transaction_date"`
	IsPaid           bool               `json:"is_paid"`
	Notes            pgtype.Text        `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	TransferPairID   pgtype.UUID        `json:"transfer_pair_id"`
	CategoryID       pgtype.Int4        `json:"category_id"`
	IsCcPayment      bool               `json:"is_cc_payment"`
	BilledAt         pgtype.Timestamptz `json:"billed_at"`
	SettlementIntent pgtype.Text        `json:"settlement_intent"`
	Source           pgtype.Text        `json:"source"`
	TemplateID       pgtype.Int4        `json:"template_id"`
	IsProjected      pgtype.Bool        `json:"is_projected"`
	LoanID           pgtype.Int4        `json:"loan_id"`
	GroupID          pgtype.Int4        `json:"group_id"`
	AccountName      string             `json:"account_name"`
}

// Returns all transactions for a specific category in a month
func (q *Queries) GetCategoryTransactions(ctx context.Context, arg GetCategoryTransactionsParams) ([]GetCategoryTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getCategoryTransactions,
		arg.WorkspaceID,
		arg.CategoryID,
		arg.Year,
		arg.Month,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryTransactionsRow{}
	for rows.Next() {
		var i GetCategoryTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.Name,
			&i.Amount,
			&i.Type,
			&i.TransactionDate,
			&i.IsPaid,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TransferPairID,
			&i.CategoryID,
			&i.IsCcPayment,
			&i.BilledAt,
			&i.SettlementIntent,
			&i.Source,
			&i.TemplateID,
			&i.IsProjected,
			&i.LoanID,
			&i.GroupID,
			&i.AccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendingByCategory = `-- name: GetSpendingByCategory :many
SELECT
    t.category_id,
    COALESCE(SUM(t.amount), 0) AS spent
FROM transactions t
WHERE t.workspace_id = $1
    AND t.category_id IS NOT NULL
    AND t.type = 'expense'
    AND t.deleted_at IS NULL
    AND EXTRACT(YEAR FROM t.transaction_date) = $2::int
    AND EXTRACT(MONTH FROM t.transaction_date) = $3::int
GROUP BY t.category_id
`

type GetSpendingByCategoryParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	Year        int32 `json:"year"`
	Month       int32 `json:"month"`
}

type GetSpendingByCategoryRow struct {
	CategoryID pgtype.Int4 `json:"category_id"`
	Spent      interface{} `json:"spent"`
}

// Returns total spending per category for a specific month
func (q *Queries) GetSpendingByCategory(ctx context.Context, arg GetSpendingByCategoryParams) ([]GetSpendingByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getSpendingByCategory, arg.WorkspaceID, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSpendingByCategoryRow{}
	for rows.Next() {
		var i GetSpendingByCategoryRow
		if err := rows.Scan(&i.CategoryID, &i.Spent); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertBudgetAllocation = `-- name: UpsertBudgetAllocation :one
INSERT INTO budget_allocations (workspace_id, category_id, year, month, amount)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (workspace_id, category_id, year, month)
DO UPDATE SET amount = EXCLUDED.amount, updated_at = NOW()
RETURNING id, workspace_id, category_id, year, month, amount, created_at, updated_at
`

type UpsertBudgetAllocationParams struct {
	WorkspaceID int32          `json:"workspace_id"`
	CategoryID  int32          `json:"category_id"`
	Year        int32          `json:"year"`
	Month       int32          `json:"month"`
	Amount      pgtype.Numeric `json:"amount"`
}

func (q *Queries) UpsertBudgetAllocation(ctx context.Context, arg UpsertBudgetAllocationParams) (BudgetAllocation, error) {
	row := q.db.QueryRow(ctx, upsertBudgetAllocation,
		arg.WorkspaceID,
		arg.CategoryID,
		arg.Year,
		arg.Month,
		arg.Amount,
	)
	var i BudgetAllocation
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.CategoryID,
		&i.Year,
		&i.Month,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
