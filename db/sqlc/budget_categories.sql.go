// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: budget_categories.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTransactionsByCategory = `-- name: CountTransactionsByCategory :one
SELECT COUNT(*)::bigint AS count
FROM transactions
WHERE workspace_id = $1
  AND category_id = $2
  AND deleted_at IS NULL
`

type CountTransactionsByCategoryParams struct {
	WorkspaceID int32       `json:"workspace_id"`
	CategoryID  pgtype.Int4 `json:"category_id"`
}

// Count transactions assigned to a specific category
func (q *Queries) CountTransactionsByCategory(ctx context.Context, arg CountTransactionsByCategoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTransactionsByCategory, arg.WorkspaceID, arg.CategoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBudgetCategory = `-- name: CreateBudgetCategory :one
INSERT INTO budget_categories (workspace_id, name)
VALUES ($1, $2)
RETURNING id, workspace_id, name, created_at, updated_at, deleted_at
`

type CreateBudgetCategoryParams struct {
	WorkspaceID int32  `json:"workspace_id"`
	Name        string `json:"name"`
}

func (q *Queries) CreateBudgetCategory(ctx context.Context, arg CreateBudgetCategoryParams) (BudgetCategory, error) {
	row := q.db.QueryRow(ctx, createBudgetCategory, arg.WorkspaceID, arg.Name)
	var i BudgetCategory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAllBudgetCategories = `-- name: GetAllBudgetCategories :many
SELECT id, workspace_id, name, created_at, updated_at, deleted_at FROM budget_categories
WHERE workspace_id = $1 AND deleted_at IS NULL
ORDER BY name ASC
`

func (q *Queries) GetAllBudgetCategories(ctx context.Context, workspaceID int32) ([]BudgetCategory, error) {
	rows, err := q.db.Query(ctx, getAllBudgetCategories, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BudgetCategory{}
	for rows.Next() {
		var i BudgetCategory
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetCategoryByID = `-- name: GetBudgetCategoryByID :one
SELECT id, workspace_id, name, created_at, updated_at, deleted_at FROM budget_categories
WHERE workspace_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetBudgetCategoryByIDParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	ID          int32 `json:"id"`
}

func (q *Queries) GetBudgetCategoryByID(ctx context.Context, arg GetBudgetCategoryByIDParams) (BudgetCategory, error) {
	row := q.db.QueryRow(ctx, getBudgetCategoryByID, arg.WorkspaceID, arg.ID)
	var i BudgetCategory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getBudgetCategoryByName = `-- name: GetBudgetCategoryByName :one
SELECT id, workspace_id, name, created_at, updated_at, deleted_at FROM budget_categories
WHERE workspace_id = $1 AND name = $2 AND deleted_at IS NULL
`

type GetBudgetCategoryByNameParams struct {
	WorkspaceID int32  `json:"workspace_id"`
	Name        string `json:"name"`
}

func (q *Queries) GetBudgetCategoryByName(ctx context.Context, arg GetBudgetCategoryByNameParams) (BudgetCategory, error) {
	row := q.db.QueryRow(ctx, getBudgetCategoryByName, arg.WorkspaceID, arg.Name)
	var i BudgetCategory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const softDeleteBudgetCategory = `-- name: SoftDeleteBudgetCategory :exec
UPDATE budget_categories
SET deleted_at = NOW(), updated_at = NOW()
WHERE workspace_id = $1 AND id = $2 AND deleted_at IS NULL
`

type SoftDeleteBudgetCategoryParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	ID          int32 `json:"id"`
}

func (q *Queries) SoftDeleteBudgetCategory(ctx context.Context, arg SoftDeleteBudgetCategoryParams) error {
	_, err := q.db.Exec(ctx, softDeleteBudgetCategory, arg.WorkspaceID, arg.ID)
	return err
}

const updateBudgetCategory = `-- name: UpdateBudgetCategory :one
UPDATE budget_categories
SET name = $3, updated_at = NOW()
WHERE workspace_id = $1 AND id = $2 AND deleted_at IS NULL
RETURNING id, workspace_id, name, created_at, updated_at, deleted_at
`

type UpdateBudgetCategoryParams struct {
	WorkspaceID int32  `json:"workspace_id"`
	ID          int32  `json:"id"`
	Name        string `json:"name"`
}

func (q *Queries) UpdateBudgetCategory(ctx context.Context, arg UpdateBudgetCategoryParams) (BudgetCategory, error) {
	row := q.db.QueryRow(ctx, updateBudgetCategory, arg.WorkspaceID, arg.ID, arg.Name)
	var i BudgetCategory
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
