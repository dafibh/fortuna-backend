// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: wishlist_item_notes.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countNotesByItem = `-- name: CountNotesByItem :one
SELECT COUNT(*) FROM wishlist_item_notes win
JOIN wishlist_items wi ON wi.id = win.item_id
JOIN wishlists w ON w.id = wi.wishlist_id
WHERE win.item_id = $1 AND w.workspace_id = $2 AND win.deleted_at IS NULL
AND wi.deleted_at IS NULL AND w.deleted_at IS NULL
`

type CountNotesByItemParams struct {
	ItemID      int32 `json:"item_id"`
	WorkspaceID int32 `json:"workspace_id"`
}

func (q *Queries) CountNotesByItem(ctx context.Context, arg CountNotesByItemParams) (int64, error) {
	row := q.db.QueryRow(ctx, countNotesByItem, arg.ItemID, arg.WorkspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWishlistItemNote = `-- name: CreateWishlistItemNote :one
INSERT INTO wishlist_item_notes (item_id, content, image_url)
VALUES ($1, $2, $3)
RETURNING id, item_id, content, created_at, updated_at, deleted_at, image_url
`

type CreateWishlistItemNoteParams struct {
	ItemID   int32       `json:"item_id"`
	Content  string      `json:"content"`
	ImageUrl pgtype.Text `json:"image_url"`
}

func (q *Queries) CreateWishlistItemNote(ctx context.Context, arg CreateWishlistItemNoteParams) (WishlistItemNote, error) {
	row := q.db.QueryRow(ctx, createWishlistItemNote, arg.ItemID, arg.Content, arg.ImageUrl)
	var i WishlistItemNote
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ImageUrl,
	)
	return i, err
}

const deleteWishlistItemNote = `-- name: DeleteWishlistItemNote :exec
UPDATE wishlist_item_notes win
SET deleted_at = NOW()
FROM wishlist_items wi, wishlists w
WHERE win.id = $1 AND win.item_id = wi.id AND wi.wishlist_id = w.id AND w.workspace_id = $2
AND win.deleted_at IS NULL AND wi.deleted_at IS NULL AND w.deleted_at IS NULL
`

type DeleteWishlistItemNoteParams struct {
	ID          int32 `json:"id"`
	WorkspaceID int32 `json:"workspace_id"`
}

func (q *Queries) DeleteWishlistItemNote(ctx context.Context, arg DeleteWishlistItemNoteParams) error {
	_, err := q.db.Exec(ctx, deleteWishlistItemNote, arg.ID, arg.WorkspaceID)
	return err
}

const getWishlistItemNoteByID = `-- name: GetWishlistItemNoteByID :one
SELECT win.id, win.item_id, win.content, win.created_at, win.updated_at, win.deleted_at, win.image_url FROM wishlist_item_notes win
JOIN wishlist_items wi ON wi.id = win.item_id
JOIN wishlists w ON w.id = wi.wishlist_id
WHERE win.id = $1 AND w.workspace_id = $2 AND win.deleted_at IS NULL
AND wi.deleted_at IS NULL AND w.deleted_at IS NULL
`

type GetWishlistItemNoteByIDParams struct {
	ID          int32 `json:"id"`
	WorkspaceID int32 `json:"workspace_id"`
}

func (q *Queries) GetWishlistItemNoteByID(ctx context.Context, arg GetWishlistItemNoteByIDParams) (WishlistItemNote, error) {
	row := q.db.QueryRow(ctx, getWishlistItemNoteByID, arg.ID, arg.WorkspaceID)
	var i WishlistItemNote
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ImageUrl,
	)
	return i, err
}

const listNotesByItemAsc = `-- name: ListNotesByItemAsc :many
SELECT win.id, win.item_id, win.content, win.created_at, win.updated_at, win.deleted_at, win.image_url FROM wishlist_item_notes win
JOIN wishlist_items wi ON wi.id = win.item_id
JOIN wishlists w ON w.id = wi.wishlist_id
WHERE win.item_id = $1 AND w.workspace_id = $2 AND win.deleted_at IS NULL
AND wi.deleted_at IS NULL AND w.deleted_at IS NULL
ORDER BY win.created_at ASC
`

type ListNotesByItemAscParams struct {
	ItemID      int32 `json:"item_id"`
	WorkspaceID int32 `json:"workspace_id"`
}

func (q *Queries) ListNotesByItemAsc(ctx context.Context, arg ListNotesByItemAscParams) ([]WishlistItemNote, error) {
	rows, err := q.db.Query(ctx, listNotesByItemAsc, arg.ItemID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WishlistItemNote{}
	for rows.Next() {
		var i WishlistItemNote
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesByItemDesc = `-- name: ListNotesByItemDesc :many
SELECT win.id, win.item_id, win.content, win.created_at, win.updated_at, win.deleted_at, win.image_url FROM wishlist_item_notes win
JOIN wishlist_items wi ON wi.id = win.item_id
JOIN wishlists w ON w.id = wi.wishlist_id
WHERE win.item_id = $1 AND w.workspace_id = $2 AND win.deleted_at IS NULL
AND wi.deleted_at IS NULL AND w.deleted_at IS NULL
ORDER BY win.created_at DESC
`

type ListNotesByItemDescParams struct {
	ItemID      int32 `json:"item_id"`
	WorkspaceID int32 `json:"workspace_id"`
}

func (q *Queries) ListNotesByItemDesc(ctx context.Context, arg ListNotesByItemDescParams) ([]WishlistItemNote, error) {
	rows, err := q.db.Query(ctx, listNotesByItemDesc, arg.ItemID, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WishlistItemNote{}
	for rows.Next() {
		var i WishlistItemNote
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWishlistItemNote = `-- name: UpdateWishlistItemNote :one
UPDATE wishlist_item_notes win
SET content = $3, image_url = $4, updated_at = NOW()
FROM wishlist_items wi, wishlists w
WHERE win.id = $1 AND win.item_id = wi.id AND wi.wishlist_id = w.id AND w.workspace_id = $2
AND win.deleted_at IS NULL AND wi.deleted_at IS NULL AND w.deleted_at IS NULL
RETURNING win.id, win.item_id, win.content, win.created_at, win.updated_at, win.deleted_at, win.image_url
`

type UpdateWishlistItemNoteParams struct {
	ID          int32       `json:"id"`
	WorkspaceID int32       `json:"workspace_id"`
	Content     string      `json:"content"`
	ImageUrl    pgtype.Text `json:"image_url"`
}

func (q *Queries) UpdateWishlistItemNote(ctx context.Context, arg UpdateWishlistItemNoteParams) (WishlistItemNote, error) {
	row := q.db.QueryRow(ctx, updateWishlistItemNote,
		arg.ID,
		arg.WorkspaceID,
		arg.Content,
		arg.ImageUrl,
	)
	var i WishlistItemNote
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ImageUrl,
	)
	return i, err
}
