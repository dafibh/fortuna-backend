// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projection_exclusions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProjectionExclusion = `-- name: CreateProjectionExclusion :exec
INSERT INTO projection_exclusions (workspace_id, template_id, excluded_month)
VALUES ($1, $2, $3)
ON CONFLICT (workspace_id, template_id, excluded_month) DO NOTHING
`

type CreateProjectionExclusionParams struct {
	WorkspaceID   int32       `json:"workspace_id"`
	TemplateID    int32       `json:"template_id"`
	ExcludedMonth pgtype.Date `json:"excluded_month"`
}

func (q *Queries) CreateProjectionExclusion(ctx context.Context, arg CreateProjectionExclusionParams) error {
	_, err := q.db.Exec(ctx, createProjectionExclusion, arg.WorkspaceID, arg.TemplateID, arg.ExcludedMonth)
	return err
}

const deleteExclusionsByTemplate = `-- name: DeleteExclusionsByTemplate :exec
DELETE FROM projection_exclusions WHERE template_id = $1
`

func (q *Queries) DeleteExclusionsByTemplate(ctx context.Context, templateID int32) error {
	_, err := q.db.Exec(ctx, deleteExclusionsByTemplate, templateID)
	return err
}

const getExclusionsByTemplate = `-- name: GetExclusionsByTemplate :many
SELECT id, workspace_id, template_id, excluded_month, created_at FROM projection_exclusions
WHERE workspace_id = $1 AND template_id = $2
ORDER BY excluded_month
`

type GetExclusionsByTemplateParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	TemplateID  int32 `json:"template_id"`
}

func (q *Queries) GetExclusionsByTemplate(ctx context.Context, arg GetExclusionsByTemplateParams) ([]ProjectionExclusion, error) {
	rows, err := q.db.Query(ctx, getExclusionsByTemplate, arg.WorkspaceID, arg.TemplateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectionExclusion{}
	for rows.Next() {
		var i ProjectionExclusion
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.TemplateID,
			&i.ExcludedMonth,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isMonthExcluded = `-- name: IsMonthExcluded :one
SELECT EXISTS(
    SELECT 1 FROM projection_exclusions
    WHERE workspace_id = $1 AND template_id = $2 AND excluded_month = $3
) AS excluded
`

type IsMonthExcludedParams struct {
	WorkspaceID   int32       `json:"workspace_id"`
	TemplateID    int32       `json:"template_id"`
	ExcludedMonth pgtype.Date `json:"excluded_month"`
}

func (q *Queries) IsMonthExcluded(ctx context.Context, arg IsMonthExcludedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isMonthExcluded, arg.WorkspaceID, arg.TemplateID, arg.ExcludedMonth)
	var excluded bool
	err := row.Scan(&excluded)
	return excluded, err
}
