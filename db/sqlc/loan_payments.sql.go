// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: loan_payments.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const batchUpdatePaid = `-- name: BatchUpdatePaid :execrows
UPDATE loan_payments
SET paid = TRUE, paid_date = $2, updated_at = NOW()
WHERE id = ANY($1::int[])
  AND paid = FALSE
`

type BatchUpdatePaidParams struct {
	Column1  []int32     `json:"column_1"`
	PaidDate pgtype.Date `json:"paid_date"`
}

// Atomically marks multiple loan payments as paid
// Used for Pay Month action in consolidated monthly mode
// Returns the number of rows affected
func (q *Queries) BatchUpdatePaid(ctx context.Context, arg BatchUpdatePaidParams) (int64, error) {
	result, err := q.db.Exec(ctx, batchUpdatePaid, arg.Column1, arg.PaidDate)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const batchUpdateUnpaid = `-- name: BatchUpdateUnpaid :execrows
UPDATE loan_payments
SET paid = FALSE, paid_date = NULL, updated_at = NOW()
WHERE id = ANY($1::int[])
  AND paid = TRUE
`

// Atomically marks multiple loan payments as unpaid
// Used for Unpay Month action in consolidated monthly mode
// Returns the number of rows affected
func (q *Queries) BatchUpdateUnpaid(ctx context.Context, dollar_1 []int32) (int64, error) {
	result, err := q.db.Exec(ctx, batchUpdateUnpaid, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createLoanPayment = `-- name: CreateLoanPayment :one
INSERT INTO loan_payments (
    loan_id,
    payment_number,
    amount,
    due_year,
    due_month,
    paid,
    paid_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, loan_id, payment_number, amount, due_year, due_month, paid, paid_date, created_at, updated_at
`

type CreateLoanPaymentParams struct {
	LoanID        int32          `json:"loan_id"`
	PaymentNumber int32          `json:"payment_number"`
	Amount        pgtype.Numeric `json:"amount"`
	DueYear       int32          `json:"due_year"`
	DueMonth      int32          `json:"due_month"`
	Paid          bool           `json:"paid"`
	PaidDate      pgtype.Date    `json:"paid_date"`
}

func (q *Queries) CreateLoanPayment(ctx context.Context, arg CreateLoanPaymentParams) (LoanPayment, error) {
	row := q.db.QueryRow(ctx, createLoanPayment,
		arg.LoanID,
		arg.PaymentNumber,
		arg.Amount,
		arg.DueYear,
		arg.DueMonth,
		arg.Paid,
		arg.PaidDate,
	)
	var i LoanPayment
	err := row.Scan(
		&i.ID,
		&i.LoanID,
		&i.PaymentNumber,
		&i.Amount,
		&i.DueYear,
		&i.DueMonth,
		&i.Paid,
		&i.PaidDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEarliestUnpaidMonth = `-- name: GetEarliestUnpaidMonth :one
SELECT lp.due_year, lp.due_month
FROM loan_payments lp
JOIN loans l ON l.id = lp.loan_id
WHERE l.workspace_id = $1
  AND l.provider_id = $2
  AND lp.paid = FALSE
  AND l.deleted_at IS NULL
ORDER BY lp.due_year ASC, lp.due_month ASC
LIMIT 1
`

type GetEarliestUnpaidMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	ProviderID  int32 `json:"provider_id"`
}

type GetEarliestUnpaidMonthRow struct {
	DueYear  int32 `json:"due_year"`
	DueMonth int32 `json:"due_month"`
}

// Returns the earliest (year, month) with unpaid payments for a provider
// This is used for sequential enforcement in consolidated monthly payment mode
// Handles gap months by finding the earliest unpaid month in ANY loan period
func (q *Queries) GetEarliestUnpaidMonth(ctx context.Context, arg GetEarliestUnpaidMonthParams) (GetEarliestUnpaidMonthRow, error) {
	row := q.db.QueryRow(ctx, getEarliestUnpaidMonth, arg.WorkspaceID, arg.ProviderID)
	var i GetEarliestUnpaidMonthRow
	err := row.Scan(&i.DueYear, &i.DueMonth)
	return i, err
}

const getLatestPaidMonth = `-- name: GetLatestPaidMonth :one
SELECT lp.due_year, lp.due_month
FROM loan_payments lp
JOIN loans l ON l.id = lp.loan_id
WHERE l.workspace_id = $1
  AND l.provider_id = $2
  AND lp.paid = TRUE
  AND l.deleted_at IS NULL
ORDER BY lp.due_year DESC, lp.due_month DESC
LIMIT 1
`

type GetLatestPaidMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	ProviderID  int32 `json:"provider_id"`
}

type GetLatestPaidMonthRow struct {
	DueYear  int32 `json:"due_year"`
	DueMonth int32 `json:"due_month"`
}

// Returns the latest (year, month) with paid payments for a provider
// Used for reverse sequential enforcement in unpay action
func (q *Queries) GetLatestPaidMonth(ctx context.Context, arg GetLatestPaidMonthParams) (GetLatestPaidMonthRow, error) {
	row := q.db.QueryRow(ctx, getLatestPaidMonth, arg.WorkspaceID, arg.ProviderID)
	var i GetLatestPaidMonthRow
	err := row.Scan(&i.DueYear, &i.DueMonth)
	return i, err
}

const getLoanDeleteStats = `-- name: GetLoanDeleteStats :one
SELECT
    COUNT(*)::INTEGER as total_count,
    COUNT(*) FILTER (WHERE paid = true)::INTEGER as paid_count,
    COUNT(*) FILTER (WHERE paid = false)::INTEGER as unpaid_count,
    COALESCE(SUM(amount), 0)::NUMERIC(12,2) as total_amount
FROM loan_payments
WHERE loan_id = $1
`

type GetLoanDeleteStatsRow struct {
	TotalCount  int32          `json:"total_count"`
	PaidCount   int32          `json:"paid_count"`
	UnpaidCount int32          `json:"unpaid_count"`
	TotalAmount pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) GetLoanDeleteStats(ctx context.Context, loanID int32) (GetLoanDeleteStatsRow, error) {
	row := q.db.QueryRow(ctx, getLoanDeleteStats, loanID)
	var i GetLoanDeleteStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.PaidCount,
		&i.UnpaidCount,
		&i.TotalAmount,
	)
	return i, err
}

const getLoanPaymentByID = `-- name: GetLoanPaymentByID :one
SELECT id, loan_id, payment_number, amount, due_year, due_month, paid, paid_date, created_at, updated_at FROM loan_payments
WHERE id = $1
`

func (q *Queries) GetLoanPaymentByID(ctx context.Context, id int32) (LoanPayment, error) {
	row := q.db.QueryRow(ctx, getLoanPaymentByID, id)
	var i LoanPayment
	err := row.Scan(
		&i.ID,
		&i.LoanID,
		&i.PaymentNumber,
		&i.Amount,
		&i.DueYear,
		&i.DueMonth,
		&i.Paid,
		&i.PaidDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLoanPaymentByLoanAndNumber = `-- name: GetLoanPaymentByLoanAndNumber :one
SELECT id, loan_id, payment_number, amount, due_year, due_month, paid, paid_date, created_at, updated_at FROM loan_payments
WHERE loan_id = $1 AND payment_number = $2
`

type GetLoanPaymentByLoanAndNumberParams struct {
	LoanID        int32 `json:"loan_id"`
	PaymentNumber int32 `json:"payment_number"`
}

func (q *Queries) GetLoanPaymentByLoanAndNumber(ctx context.Context, arg GetLoanPaymentByLoanAndNumberParams) (LoanPayment, error) {
	row := q.db.QueryRow(ctx, getLoanPaymentByLoanAndNumber, arg.LoanID, arg.PaymentNumber)
	var i LoanPayment
	err := row.Scan(
		&i.ID,
		&i.LoanID,
		&i.PaymentNumber,
		&i.Amount,
		&i.DueYear,
		&i.DueMonth,
		&i.Paid,
		&i.PaidDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLoanPaymentsByLoanID = `-- name: GetLoanPaymentsByLoanID :many
SELECT id, loan_id, payment_number, amount, due_year, due_month, paid, paid_date, created_at, updated_at FROM loan_payments
WHERE loan_id = $1
ORDER BY payment_number
`

func (q *Queries) GetLoanPaymentsByLoanID(ctx context.Context, loanID int32) ([]LoanPayment, error) {
	rows, err := q.db.Query(ctx, getLoanPaymentsByLoanID, loanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoanPayment{}
	for rows.Next() {
		var i LoanPayment
		if err := rows.Scan(
			&i.ID,
			&i.LoanID,
			&i.PaymentNumber,
			&i.Amount,
			&i.DueYear,
			&i.DueMonth,
			&i.Paid,
			&i.PaidDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoanPaymentsByMonth = `-- name: GetLoanPaymentsByMonth :many
SELECT lp.id, lp.loan_id, lp.payment_number, lp.amount, lp.due_year, lp.due_month, lp.paid, lp.paid_date, lp.created_at, lp.updated_at FROM loan_payments lp
JOIN loans l ON lp.loan_id = l.id
WHERE l.workspace_id = $1
  AND lp.due_year = $2
  AND lp.due_month = $3
  AND l.deleted_at IS NULL
ORDER BY lp.due_year, lp.due_month, lp.payment_number
`

type GetLoanPaymentsByMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	DueYear     int32 `json:"due_year"`
	DueMonth    int32 `json:"due_month"`
}

func (q *Queries) GetLoanPaymentsByMonth(ctx context.Context, arg GetLoanPaymentsByMonthParams) ([]LoanPayment, error) {
	rows, err := q.db.Query(ctx, getLoanPaymentsByMonth, arg.WorkspaceID, arg.DueYear, arg.DueMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoanPayment{}
	for rows.Next() {
		var i LoanPayment
		if err := rows.Scan(
			&i.ID,
			&i.LoanID,
			&i.PaymentNumber,
			&i.Amount,
			&i.DueYear,
			&i.DueMonth,
			&i.Paid,
			&i.PaidDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoanPaymentsWithDetailsByMonth = `-- name: GetLoanPaymentsWithDetailsByMonth :many
SELECT
    lp.id,
    lp.loan_id,
    l.item_name,
    lp.payment_number,
    l.num_months as total_payments,
    lp.amount,
    lp.paid
FROM loan_payments lp
JOIN loans l ON l.id = lp.loan_id
WHERE l.workspace_id = $1
  AND lp.due_year = $2
  AND lp.due_month = $3
  AND l.deleted_at IS NULL
ORDER BY l.item_name, lp.payment_number
`

type GetLoanPaymentsWithDetailsByMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	DueYear     int32 `json:"due_year"`
	DueMonth    int32 `json:"due_month"`
}

type GetLoanPaymentsWithDetailsByMonthRow struct {
	ID            int32          `json:"id"`
	LoanID        int32          `json:"loan_id"`
	ItemName      string         `json:"item_name"`
	PaymentNumber int32          `json:"payment_number"`
	TotalPayments int32          `json:"total_payments"`
	Amount        pgtype.Numeric `json:"amount"`
	Paid          bool           `json:"paid"`
}

func (q *Queries) GetLoanPaymentsWithDetailsByMonth(ctx context.Context, arg GetLoanPaymentsWithDetailsByMonthParams) ([]GetLoanPaymentsWithDetailsByMonthRow, error) {
	rows, err := q.db.Query(ctx, getLoanPaymentsWithDetailsByMonth, arg.WorkspaceID, arg.DueYear, arg.DueMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLoanPaymentsWithDetailsByMonthRow{}
	for rows.Next() {
		var i GetLoanPaymentsWithDetailsByMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.LoanID,
			&i.ItemName,
			&i.PaymentNumber,
			&i.TotalPayments,
			&i.Amount,
			&i.Paid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaidPaymentsByProviderMonth = `-- name: GetPaidPaymentsByProviderMonth :many
SELECT lp.id, lp.loan_id, lp.payment_number, lp.amount, lp.due_year, lp.due_month, lp.paid, lp.paid_date, lp.created_at, lp.updated_at FROM loan_payments lp
JOIN loans l ON l.id = lp.loan_id
WHERE l.workspace_id = $1
  AND l.provider_id = $2
  AND lp.due_year = $3
  AND lp.due_month = $4
  AND lp.paid = TRUE
  AND l.deleted_at IS NULL
ORDER BY l.item_name, lp.payment_number
`

type GetPaidPaymentsByProviderMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	ProviderID  int32 `json:"provider_id"`
	DueYear     int32 `json:"due_year"`
	DueMonth    int32 `json:"due_month"`
}

// Returns all paid loan payments for a specific provider and month
// Used for Unpay Month action in consolidated monthly mode
func (q *Queries) GetPaidPaymentsByProviderMonth(ctx context.Context, arg GetPaidPaymentsByProviderMonthParams) ([]LoanPayment, error) {
	rows, err := q.db.Query(ctx, getPaidPaymentsByProviderMonth,
		arg.WorkspaceID,
		arg.ProviderID,
		arg.DueYear,
		arg.DueMonth,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoanPayment{}
	for rows.Next() {
		var i LoanPayment
		if err := rows.Scan(
			&i.ID,
			&i.LoanID,
			&i.PaymentNumber,
			&i.Amount,
			&i.DueYear,
			&i.DueMonth,
			&i.Paid,
			&i.PaidDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByIDs = `-- name: GetPaymentsByIDs :many
SELECT lp.id, lp.loan_id, lp.payment_number, lp.amount, lp.due_year, lp.due_month, lp.paid, lp.paid_date, lp.created_at, lp.updated_at FROM loan_payments lp
JOIN loans l ON l.id = lp.loan_id
WHERE lp.id = ANY($1::int[])
  AND l.workspace_id = $2
  AND l.deleted_at IS NULL
`

type GetPaymentsByIDsParams struct {
	Column1     []int32 `json:"column_1"`
	WorkspaceID int32   `json:"workspace_id"`
}

// Returns loan payments by their IDs with workspace validation via join
func (q *Queries) GetPaymentsByIDs(ctx context.Context, arg GetPaymentsByIDsParams) ([]LoanPayment, error) {
	rows, err := q.db.Query(ctx, getPaymentsByIDs, arg.Column1, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoanPayment{}
	for rows.Next() {
		var i LoanPayment
		if err := rows.Scan(
			&i.ID,
			&i.LoanID,
			&i.PaymentNumber,
			&i.Amount,
			&i.DueYear,
			&i.DueMonth,
			&i.Paid,
			&i.PaidDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrendByMonth = `-- name: GetTrendByMonth :many
SELECT
  lp.due_year,
  lp.due_month,
  l.provider_id,
  lpr.name AS provider_name,
  COALESCE(SUM(lp.amount), 0)::NUMERIC(12,2) AS total,
  BOOL_AND(lp.paid) AS is_paid
FROM loan_payments lp
JOIN loans l ON lp.loan_id = l.id
JOIN loan_providers lpr ON l.provider_id = lpr.id
WHERE l.workspace_id = $1
  AND l.deleted_at IS NULL
  AND lpr.deleted_at IS NULL
  AND (
    (lp.due_year > $2) OR
    (lp.due_year = $2 AND lp.due_month >= $3)
  )
GROUP BY lp.due_year, lp.due_month, l.provider_id, lpr.name
ORDER BY lp.due_year, lp.due_month, l.provider_id
`

type GetTrendByMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	DueYear     int32 `json:"due_year"`
	DueMonth    int32 `json:"due_month"`
}

type GetTrendByMonthRow struct {
	DueYear      int32          `json:"due_year"`
	DueMonth     int32          `json:"due_month"`
	ProviderID   int32          `json:"provider_id"`
	ProviderName string         `json:"provider_name"`
	Total        pgtype.Numeric `json:"total"`
	IsPaid       bool           `json:"is_paid"`
}

// Aggregates loan payments by year/month and provider for trend visualization
// Returns monthly totals with provider breakdown and isPaid status
// Gap months (no payments) are handled in the service layer
func (q *Queries) GetTrendByMonth(ctx context.Context, arg GetTrendByMonthParams) ([]GetTrendByMonthRow, error) {
	rows, err := q.db.Query(ctx, getTrendByMonth, arg.WorkspaceID, arg.DueYear, arg.DueMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTrendByMonthRow{}
	for rows.Next() {
		var i GetTrendByMonthRow
		if err := rows.Scan(
			&i.DueYear,
			&i.DueMonth,
			&i.ProviderID,
			&i.ProviderName,
			&i.Total,
			&i.IsPaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnpaidLoanPaymentsByMonth = `-- name: GetUnpaidLoanPaymentsByMonth :many
SELECT lp.id, lp.loan_id, lp.payment_number, lp.amount, lp.due_year, lp.due_month, lp.paid, lp.paid_date, lp.created_at, lp.updated_at FROM loan_payments lp
JOIN loans l ON lp.loan_id = l.id
WHERE l.workspace_id = $1
  AND lp.due_year = $2
  AND lp.due_month = $3
  AND lp.paid = FALSE
  AND l.deleted_at IS NULL
ORDER BY lp.due_year, lp.due_month, lp.payment_number
`

type GetUnpaidLoanPaymentsByMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	DueYear     int32 `json:"due_year"`
	DueMonth    int32 `json:"due_month"`
}

func (q *Queries) GetUnpaidLoanPaymentsByMonth(ctx context.Context, arg GetUnpaidLoanPaymentsByMonthParams) ([]LoanPayment, error) {
	rows, err := q.db.Query(ctx, getUnpaidLoanPaymentsByMonth, arg.WorkspaceID, arg.DueYear, arg.DueMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoanPayment{}
	for rows.Next() {
		var i LoanPayment
		if err := rows.Scan(
			&i.ID,
			&i.LoanID,
			&i.PaymentNumber,
			&i.Amount,
			&i.DueYear,
			&i.DueMonth,
			&i.Paid,
			&i.PaidDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnpaidPaymentsByProviderMonth = `-- name: GetUnpaidPaymentsByProviderMonth :many
SELECT lp.id, lp.loan_id, lp.payment_number, lp.amount, lp.due_year, lp.due_month, lp.paid, lp.paid_date, lp.created_at, lp.updated_at FROM loan_payments lp
JOIN loans l ON l.id = lp.loan_id
WHERE l.workspace_id = $1
  AND l.provider_id = $2
  AND lp.due_year = $3
  AND lp.due_month = $4
  AND lp.paid = FALSE
  AND l.deleted_at IS NULL
ORDER BY l.item_name, lp.payment_number
`

type GetUnpaidPaymentsByProviderMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	ProviderID  int32 `json:"provider_id"`
	DueYear     int32 `json:"due_year"`
	DueMonth    int32 `json:"due_month"`
}

// Returns all unpaid loan payments for a specific provider and month
// Used for Pay Month action in consolidated monthly mode
func (q *Queries) GetUnpaidPaymentsByProviderMonth(ctx context.Context, arg GetUnpaidPaymentsByProviderMonthParams) ([]LoanPayment, error) {
	rows, err := q.db.Query(ctx, getUnpaidPaymentsByProviderMonth,
		arg.WorkspaceID,
		arg.ProviderID,
		arg.DueYear,
		arg.DueMonth,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoanPayment{}
	for rows.Next() {
		var i LoanPayment
		if err := rows.Scan(
			&i.ID,
			&i.LoanID,
			&i.PaymentNumber,
			&i.Amount,
			&i.DueYear,
			&i.DueMonth,
			&i.Paid,
			&i.PaidDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sumPaymentAmountsByIDs = `-- name: SumPaymentAmountsByIDs :one
SELECT COALESCE(SUM(lp.amount), 0)::NUMERIC(12,2) as total
FROM loan_payments lp
JOIN loans l ON l.id = lp.loan_id
WHERE lp.id = ANY($1::int[])
  AND l.workspace_id = $2
  AND l.deleted_at IS NULL
`

type SumPaymentAmountsByIDsParams struct {
	Column1     []int32 `json:"column_1"`
	WorkspaceID int32   `json:"workspace_id"`
}

// Returns the sum of amounts for given payment IDs
func (q *Queries) SumPaymentAmountsByIDs(ctx context.Context, arg SumPaymentAmountsByIDsParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, sumPaymentAmountsByIDs, arg.Column1, arg.WorkspaceID)
	var total pgtype.Numeric
	err := row.Scan(&total)
	return total, err
}

const sumUnpaidLoanPaymentsByMonth = `-- name: SumUnpaidLoanPaymentsByMonth :one
SELECT COALESCE(SUM(lp.amount), 0)::NUMERIC(12,2) as total
FROM loan_payments lp
JOIN loans l ON l.id = lp.loan_id
WHERE l.workspace_id = $1
  AND lp.due_year = $2
  AND lp.due_month = $3
  AND lp.paid = FALSE
  AND l.deleted_at IS NULL
`

type SumUnpaidLoanPaymentsByMonthParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	DueYear     int32 `json:"due_year"`
	DueMonth    int32 `json:"due_month"`
}

func (q *Queries) SumUnpaidLoanPaymentsByMonth(ctx context.Context, arg SumUnpaidLoanPaymentsByMonthParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, sumUnpaidLoanPaymentsByMonth, arg.WorkspaceID, arg.DueYear, arg.DueMonth)
	var total pgtype.Numeric
	err := row.Scan(&total)
	return total, err
}

const toggleLoanPaymentPaid = `-- name: ToggleLoanPaymentPaid :one
UPDATE loan_payments
SET paid = $2, paid_date = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, loan_id, payment_number, amount, due_year, due_month, paid, paid_date, created_at, updated_at
`

type ToggleLoanPaymentPaidParams struct {
	ID       int32       `json:"id"`
	Paid     bool        `json:"paid"`
	PaidDate pgtype.Date `json:"paid_date"`
}

func (q *Queries) ToggleLoanPaymentPaid(ctx context.Context, arg ToggleLoanPaymentPaidParams) (LoanPayment, error) {
	row := q.db.QueryRow(ctx, toggleLoanPaymentPaid, arg.ID, arg.Paid, arg.PaidDate)
	var i LoanPayment
	err := row.Scan(
		&i.ID,
		&i.LoanID,
		&i.PaymentNumber,
		&i.Amount,
		&i.DueYear,
		&i.DueMonth,
		&i.Paid,
		&i.PaidDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLoanPaymentAmount = `-- name: UpdateLoanPaymentAmount :one
UPDATE loan_payments
SET amount = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, loan_id, payment_number, amount, due_year, due_month, paid, paid_date, created_at, updated_at
`

type UpdateLoanPaymentAmountParams struct {
	ID     int32          `json:"id"`
	Amount pgtype.Numeric `json:"amount"`
}

func (q *Queries) UpdateLoanPaymentAmount(ctx context.Context, arg UpdateLoanPaymentAmountParams) (LoanPayment, error) {
	row := q.db.QueryRow(ctx, updateLoanPaymentAmount, arg.ID, arg.Amount)
	var i LoanPayment
	err := row.Scan(
		&i.ID,
		&i.LoanID,
		&i.PaymentNumber,
		&i.Amount,
		&i.DueYear,
		&i.DueMonth,
		&i.Paid,
		&i.PaidDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
