// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transaction_groups.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignGroupToTransactions = `-- name: AssignGroupToTransactions :exec
UPDATE transactions
SET group_id = $1, updated_at = NOW()
WHERE workspace_id = $2
  AND id = ANY($3::int[])
  AND deleted_at IS NULL
`

type AssignGroupToTransactionsParams struct {
	GroupID     pgtype.Int4 `json:"group_id"`
	WorkspaceID int32       `json:"workspace_id"`
	Column3     []int32     `json:"column_3"`
}

func (q *Queries) AssignGroupToTransactions(ctx context.Context, arg AssignGroupToTransactionsParams) error {
	_, err := q.db.Exec(ctx, assignGroupToTransactions, arg.GroupID, arg.WorkspaceID, arg.Column3)
	return err
}

const countGroupChildren = `-- name: CountGroupChildren :one
SELECT COUNT(*)::INTEGER as child_count
FROM transactions
WHERE group_id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type CountGroupChildrenParams struct {
	GroupID     pgtype.Int4 `json:"group_id"`
	WorkspaceID int32       `json:"workspace_id"`
}

func (q *Queries) CountGroupChildren(ctx context.Context, arg CountGroupChildrenParams) (int32, error) {
	row := q.db.QueryRow(ctx, countGroupChildren, arg.GroupID, arg.WorkspaceID)
	var child_count int32
	err := row.Scan(&child_count)
	return child_count, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO transaction_groups (
    workspace_id, name, month, auto_detected, loan_provider_id
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, workspace_id, name, month, auto_detected, loan_provider_id, created_at, updated_at
`

type CreateGroupParams struct {
	WorkspaceID    int32       `json:"workspace_id"`
	Name           string      `json:"name"`
	Month          string      `json:"month"`
	AutoDetected   bool        `json:"auto_detected"`
	LoanProviderID pgtype.Int4 `json:"loan_provider_id"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (TransactionGroup, error) {
	row := q.db.QueryRow(ctx, createGroup,
		arg.WorkspaceID,
		arg.Name,
		arg.Month,
		arg.AutoDetected,
		arg.LoanProviderID,
	)
	var i TransactionGroup
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Month,
		&i.AutoDetected,
		&i.LoanProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM transaction_groups
WHERE workspace_id = $1 AND id = $2
`

type DeleteGroupParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	ID          int32 `json:"id"`
}

func (q *Queries) DeleteGroup(ctx context.Context, arg DeleteGroupParams) error {
	_, err := q.db.Exec(ctx, deleteGroup, arg.WorkspaceID, arg.ID)
	return err
}

const getAutoDetectedGroupByProviderMonth = `-- name: GetAutoDetectedGroupByProviderMonth :one
SELECT tg.id, tg.workspace_id, tg.name, tg.month,
       tg.auto_detected, tg.loan_provider_id,
       tg.created_at, tg.updated_at,
       COALESCE(SUM(t.amount), 0)::NUMERIC(12,2) as total_amount,
       COUNT(t.id)::INTEGER as child_count
FROM transaction_groups tg
LEFT JOIN transactions t ON t.group_id = tg.id AND t.deleted_at IS NULL
WHERE tg.workspace_id = $1
  AND tg.auto_detected = true
  AND tg.loan_provider_id = $2
  AND tg.month = $3
GROUP BY tg.id
`

type GetAutoDetectedGroupByProviderMonthParams struct {
	WorkspaceID    int32       `json:"workspace_id"`
	LoanProviderID pgtype.Int4 `json:"loan_provider_id"`
	Month          string      `json:"month"`
}

type GetAutoDetectedGroupByProviderMonthRow struct {
	ID             int32              `json:"id"`
	WorkspaceID    int32              `json:"workspace_id"`
	Name           string             `json:"name"`
	Month          string             `json:"month"`
	AutoDetected   bool               `json:"auto_detected"`
	LoanProviderID pgtype.Int4        `json:"loan_provider_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	TotalAmount    pgtype.Numeric     `json:"total_amount"`
	ChildCount     int32              `json:"child_count"`
}

func (q *Queries) GetAutoDetectedGroupByProviderMonth(ctx context.Context, arg GetAutoDetectedGroupByProviderMonthParams) (GetAutoDetectedGroupByProviderMonthRow, error) {
	row := q.db.QueryRow(ctx, getAutoDetectedGroupByProviderMonth, arg.WorkspaceID, arg.LoanProviderID, arg.Month)
	var i GetAutoDetectedGroupByProviderMonthRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Month,
		&i.AutoDetected,
		&i.LoanProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TotalAmount,
		&i.ChildCount,
	)
	return i, err
}

const getConsolidatedProvidersByMonth = `-- name: GetConsolidatedProvidersByMonth :many
SELECT lp.id as provider_id, lp.name as provider_name, COUNT(t.id)::INTEGER as tx_count
FROM transactions t
JOIN loans l ON t.loan_id = l.id
JOIN loan_providers lp ON l.provider_id = lp.id
WHERE t.workspace_id = $1
  AND lp.payment_mode = 'consolidated_monthly'
  AND t.group_id IS NULL
  AND t.deleted_at IS NULL
  AND TO_CHAR(t.transaction_date, 'YYYY-MM') = $2::TEXT
GROUP BY lp.id, lp.name
HAVING COUNT(t.id) >= 2
`

type GetConsolidatedProvidersByMonthParams struct {
	WorkspaceID int32  `json:"workspace_id"`
	Month       string `json:"month"`
}

type GetConsolidatedProvidersByMonthRow struct {
	ProviderID   int32  `json:"provider_id"`
	ProviderName string `json:"provider_name"`
	TxCount      int32  `json:"tx_count"`
}

func (q *Queries) GetConsolidatedProvidersByMonth(ctx context.Context, arg GetConsolidatedProvidersByMonthParams) ([]GetConsolidatedProvidersByMonthRow, error) {
	rows, err := q.db.Query(ctx, getConsolidatedProvidersByMonth, arg.WorkspaceID, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetConsolidatedProvidersByMonthRow{}
	for rows.Next() {
		var i GetConsolidatedProvidersByMonthRow
		if err := rows.Scan(&i.ProviderID, &i.ProviderName, &i.TxCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupByID = `-- name: GetGroupByID :one
SELECT tg.id, tg.workspace_id, tg.name, tg.month,
       tg.auto_detected, tg.loan_provider_id,
       tg.created_at, tg.updated_at,
       COALESCE(SUM(t.amount), 0)::NUMERIC(12,2) as total_amount,
       COUNT(t.id)::INTEGER as child_count
FROM transaction_groups tg
LEFT JOIN transactions t ON t.group_id = tg.id AND t.deleted_at IS NULL
WHERE tg.workspace_id = $1 AND tg.id = $2
GROUP BY tg.id
`

type GetGroupByIDParams struct {
	WorkspaceID int32 `json:"workspace_id"`
	ID          int32 `json:"id"`
}

type GetGroupByIDRow struct {
	ID             int32              `json:"id"`
	WorkspaceID    int32              `json:"workspace_id"`
	Name           string             `json:"name"`
	Month          string             `json:"month"`
	AutoDetected   bool               `json:"auto_detected"`
	LoanProviderID pgtype.Int4        `json:"loan_provider_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	TotalAmount    pgtype.Numeric     `json:"total_amount"`
	ChildCount     int32              `json:"child_count"`
}

func (q *Queries) GetGroupByID(ctx context.Context, arg GetGroupByIDParams) (GetGroupByIDRow, error) {
	row := q.db.QueryRow(ctx, getGroupByID, arg.WorkspaceID, arg.ID)
	var i GetGroupByIDRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Month,
		&i.AutoDetected,
		&i.LoanProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TotalAmount,
		&i.ChildCount,
	)
	return i, err
}

const getGroupsByMonth = `-- name: GetGroupsByMonth :many
SELECT tg.id, tg.workspace_id, tg.name, tg.month,
       tg.auto_detected, tg.loan_provider_id,
       tg.created_at, tg.updated_at,
       COALESCE(SUM(t.amount), 0)::NUMERIC(12,2) as total_amount,
       COUNT(t.id)::INTEGER as child_count
FROM transaction_groups tg
LEFT JOIN transactions t ON t.group_id = tg.id AND t.deleted_at IS NULL
WHERE tg.workspace_id = $1 AND tg.month = $2
GROUP BY tg.id
ORDER BY tg.created_at DESC
`

type GetGroupsByMonthParams struct {
	WorkspaceID int32  `json:"workspace_id"`
	Month       string `json:"month"`
}

type GetGroupsByMonthRow struct {
	ID             int32              `json:"id"`
	WorkspaceID    int32              `json:"workspace_id"`
	Name           string             `json:"name"`
	Month          string             `json:"month"`
	AutoDetected   bool               `json:"auto_detected"`
	LoanProviderID pgtype.Int4        `json:"loan_provider_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	TotalAmount    pgtype.Numeric     `json:"total_amount"`
	ChildCount     int32              `json:"child_count"`
}

func (q *Queries) GetGroupsByMonth(ctx context.Context, arg GetGroupsByMonthParams) ([]GetGroupsByMonthRow, error) {
	rows, err := q.db.Query(ctx, getGroupsByMonth, arg.WorkspaceID, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupsByMonthRow{}
	for rows.Next() {
		var i GetGroupsByMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Month,
			&i.AutoDetected,
			&i.LoanProviderID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalAmount,
			&i.ChildCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUngroupedTransactionIDsByProviderMonth = `-- name: GetUngroupedTransactionIDsByProviderMonth :many
SELECT t.id
FROM transactions t
JOIN loans l ON t.loan_id = l.id
WHERE t.workspace_id = $1
  AND l.provider_id = $2
  AND t.group_id IS NULL
  AND t.deleted_at IS NULL
  AND TO_CHAR(t.transaction_date, 'YYYY-MM') = $3::TEXT
`

type GetUngroupedTransactionIDsByProviderMonthParams struct {
	WorkspaceID int32  `json:"workspace_id"`
	ProviderID  int32  `json:"provider_id"`
	Month       string `json:"month"`
}

func (q *Queries) GetUngroupedTransactionIDsByProviderMonth(ctx context.Context, arg GetUngroupedTransactionIDsByProviderMonthParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, getUngroupedTransactionIDsByProviderMonth, arg.WorkspaceID, arg.ProviderID, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUngroupedTransactionsByMonth = `-- name: GetUngroupedTransactionsByMonth :many
SELECT id, workspace_id, account_id, name, amount, type, transaction_date, is_paid, notes, created_at, updated_at, deleted_at, transfer_pair_id, category_id, is_cc_payment, billed_at, settlement_intent, source, template_id, is_projected, loan_id, group_id FROM transactions
WHERE workspace_id = $1
  AND group_id IS NULL
  AND transaction_date >= $2
  AND transaction_date < $3
  AND deleted_at IS NULL
ORDER BY transaction_date DESC, created_at DESC
`

type GetUngroupedTransactionsByMonthParams struct {
	WorkspaceID       int32       `json:"workspace_id"`
	TransactionDate   pgtype.Date `json:"transaction_date"`
	TransactionDate_2 pgtype.Date `json:"transaction_date_2"`
}

func (q *Queries) GetUngroupedTransactionsByMonth(ctx context.Context, arg GetUngroupedTransactionsByMonthParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getUngroupedTransactionsByMonth, arg.WorkspaceID, arg.TransactionDate, arg.TransactionDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.AccountID,
			&i.Name,
			&i.Amount,
			&i.Type,
			&i.TransactionDate,
			&i.IsPaid,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TransferPairID,
			&i.CategoryID,
			&i.IsCcPayment,
			&i.BilledAt,
			&i.SettlementIntent,
			&i.Source,
			&i.TemplateID,
			&i.IsProjected,
			&i.LoanID,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteTransactionsByGroupID = `-- name: SoftDeleteTransactionsByGroupID :execrows
UPDATE transactions SET deleted_at = NOW(), updated_at = NOW()
WHERE group_id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type SoftDeleteTransactionsByGroupIDParams struct {
	GroupID     pgtype.Int4 `json:"group_id"`
	WorkspaceID int32       `json:"workspace_id"`
}

func (q *Queries) SoftDeleteTransactionsByGroupID(ctx context.Context, arg SoftDeleteTransactionsByGroupIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteTransactionsByGroupID, arg.GroupID, arg.WorkspaceID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const unassignAllFromGroup = `-- name: UnassignAllFromGroup :execrows
UPDATE transactions SET group_id = NULL, updated_at = NOW()
WHERE group_id = $1 AND workspace_id = $2 AND deleted_at IS NULL
`

type UnassignAllFromGroupParams struct {
	GroupID     pgtype.Int4 `json:"group_id"`
	WorkspaceID int32       `json:"workspace_id"`
}

func (q *Queries) UnassignAllFromGroup(ctx context.Context, arg UnassignAllFromGroupParams) (int64, error) {
	result, err := q.db.Exec(ctx, unassignAllFromGroup, arg.GroupID, arg.WorkspaceID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const unassignGroupFromTransactions = `-- name: UnassignGroupFromTransactions :exec
UPDATE transactions
SET group_id = NULL, updated_at = NOW()
WHERE workspace_id = $1
  AND id = ANY($2::int[])
  AND deleted_at IS NULL
`

type UnassignGroupFromTransactionsParams struct {
	WorkspaceID int32   `json:"workspace_id"`
	Column2     []int32 `json:"column_2"`
}

func (q *Queries) UnassignGroupFromTransactions(ctx context.Context, arg UnassignGroupFromTransactionsParams) error {
	_, err := q.db.Exec(ctx, unassignGroupFromTransactions, arg.WorkspaceID, arg.Column2)
	return err
}

const updateGroupName = `-- name: UpdateGroupName :one
UPDATE transaction_groups
SET name = $3, updated_at = NOW()
WHERE workspace_id = $1 AND id = $2
RETURNING id, workspace_id, name, month, auto_detected, loan_provider_id, created_at, updated_at
`

type UpdateGroupNameParams struct {
	WorkspaceID int32  `json:"workspace_id"`
	ID          int32  `json:"id"`
	Name        string `json:"name"`
}

func (q *Queries) UpdateGroupName(ctx context.Context, arg UpdateGroupNameParams) (TransactionGroup, error) {
	row := q.db.QueryRow(ctx, updateGroupName, arg.WorkspaceID, arg.ID, arg.Name)
	var i TransactionGroup
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Month,
		&i.AutoDetected,
		&i.LoanProviderID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
